@startuml
GameState o-- GameMap
GameState o-- Logic
GameState o-- Player
Building o-- Player
MapReader - GameMap : reads >
GameMap o-- GameField
GameMap <|.. java.lang.Iterable
Logic <|.. java.util.Comparator
GameField o-- Building
GameField o-- Unit
Position o-- Pair
Unit o-- Position
Unit o-- Player
Player o-- Unit
Player <|-- ComputerPlayer
Unit <|-- RangedUnit
RangedUnit <|-- Dragon
Unit <|-- Soldier
GameField <|-- Grass
GameField <|-- Water
GameField <|-- Pit
BuildingGetter <|.. FuncEx
UnitGetter <|.. FuncEx
TerrainGetter <|.. FuncEx

class GameState {
      -GameMap map
      -Logic logic
      -List<Player> players
      -Integer turns
      +Integer getTurns()
      +GameState GameState(GameMap, Logic, List<Player>)
      +void advanceTurn()
      +void advancePlayer()
      +GameMap getMap()
      +void attack(Unit, Unit)
      +Boolean move(Unit, Position)
      +void play()
      +List<Player> getPlayers()
      +Boolean produceUnit(GameField, String)
      -void updateBuildingCaptureCounters()
      -Boolean removeUnitIfDead(Unit)
      
}

class GameMap {
      -List<List<GameField>> fields
      -List<Player> players
      -HashMap<Character, Unit> units
      -HashMap<Character, Building> buildings
      -HashMap<Character, GameField> gameFields
      +Iterator<GameField> iterator()
      +Integer getWidth()
      +Integer getHeight()
      +GameField getField(Integer, Integer)
      +GameField getField(Position)
      +Boolean isInsantiated()
      +Boolean isValidField(Position)
      +Boolean isValidField(Integer, Integer)
      +HashMap<Character, Unit> getUnitMap()
      +HashMap<Character, Building> getBuildingMap()
      +HashMap<Character, GameField> getGameFieldMap()
      +List<Player> getPlayers()

}

namespace java.util #DDDDDD {
      interface Comparator<T> {
            +int compare(T, T)
      }     
}


namespace java.lang #DDDDDD {
      interface Iterable<T> {
            +Iterator<T> iterator()
      }	    
}

class Position {
      -Pair<Integer, Integer> pair
      +Integer getX()
      +Integer getY()
}

class MapReader {
      -String TAG {static}
      +GameMap readMap(List<String>) {static}
      -List<List<O>> listifyJSONArray(FuncEx<Character, O, JSONException>) {static}
      -void setBuildings(List<List<GameField>>, List<Player>, HashMap<Character, Unit>, HashMap<Character, Building>, JSONArray) {static}
      -void spawnUnits(List<List<GameField>>, List<Player>, HashMap<Character, Unit>, JSONArray) {static}
      -List<O> map(FuncEx<I, O, E extends Exception>, List<I>) throws E {static}
}

class BuildingGetter {
      -HashMap<Character, JSONObject> map
      +BuildingGetter BuildingGetter(<HashMap<Character, JSONObject>)
      +Building apply(Character) throws JSONException
}

class TerrainGetter {
      -HashMap<Character, JSONObject> map
      +TerrainGetter TerrainGetter(<HashMap<Character, JSONObject>)
      +GameField apply(Character) throws JSONException
}

class UnitGetter {
      +Unit apply(JSONObject) throws JSONException
}

interface FuncEx<I, O, E extends Exception> {
      +O apply(I) throws E
}

class Pair {
      -L left
      -R right
      +Pair<L, R>
      +L getLeft()
      +R getRight()
}

abstract class Unit {	 
      -Double health
      -Double maxHealth
      -Integer attack
      -Integer meleeDefense
      -Integer rangeDefense
      -Postition position
      -Player owner
      -String name
      -Integer movement
      -Integer maxMovement
      -Boolean hasFinishedTurn
      +Boolean isDead()
      +Integer getHealth()
      +Integer getMaxHealth()
      +Integer getAttack()
      +Integer getRemainingMovement()			 	 
      +Integer getMaxMovement()			 	 
      +Integer getMeleeDefense()
      +Integer getRangeDefense()
      +Player getOwner()
      +void setOwner
      +Position getPosition()
      +void setPosition(Position)
      +void restortHealth(Double)
      +void reduceHealth(Double)
      +Boolean hasFinishedTurn()
      +Boolean canMoveTo(Position)
      +Boolean isRanged()
}

class Logic {
      +List<Position> findPath(GameMap, Unit, Position)
      +Pair<Double, Double> calculateDamage(GameMap, Unit, Unit)
      +Double calculateCounterDamage(GameMap, Unit, Unit)
      -Double calculateTheoreticalCounterDamage(GameMap, Unit, Unit, Double)
      -List<Position> AStar(GameMap, Unit, Position)
      -List<Position> getAdjacentPositions(Position)
      -class AStarComparator
      -Double getMovementCost(GameMap, Unit, Position)
      +Set<Position> getAttackableUnitPositions(GameMap, Unit)
      -Set<Position> getAttackableFields(GameMap, Unit)
      -Set<Position> getPositionsInRange(GameMap, Position, Double)
      -Integer getManhattanDistance(Position, Position)
      -Pair<Integer, Integer> getDistanceAway(Position, Position)
      
}

class Player {
      -String name
      -Color color
      -Boolean playerOwned
      -List<Unit> unitsOwned
      +Boolean isHumanPlayer()
      +String getName()
      +Boolean hasLost()
      +Boolean hasMoveableUnits()
      +void removeUnit(unit)
}

class ComputerPlayer {
      +void takeTurn()
}

abstract class Building {
      -String buildingName
      -Integer captureDifficulty
      -Integer remainingCaptureTime
      -Double attackBonus
      -Double defenseBonus
      -Player owner
      -Player lastCapturer
      -Boolean goalBuilding
      +Double getAttackBonus()
      +Double getDefenseBonus()
      +Player getLastCapturer()
      +void setLastCapturer()
      +Player getOwner()
      +String getName()
      +Boolean hasOwner()
      +void reduceCaptureTime(Integer)
      +void resetCaptureTime()
      +Integer getCaptureDifficulty()
      +Integer getRemainingCaptureTime()
      +Integer setOwner(Player)
      +Boolean isGoalBuilding()      
}

abstract class GameField {
      -String fieldName
      -Unit hostedUnit
      -Building hostedBuilding
      -Double movementModifier
      -Double defenseModifier
      -Double attackModifier
      +Double getAttackModifier()
      +Double getMovementModifier()
      +Boolean hostsUnit()
      +Boolean hostsBuilding()
      +Unit getUnit()
      +Building getBuilding()
      +Unit setUnit()
      +Building setBuilding()
}

abstract class RangedUnit {
      +Double getMinRange()
      +Double getMaxRange()
}

class Dragon {
}

class Soldier {
}

class Grass {
}

class Pit {
}

class Water {
}

hide empty members

@enduml